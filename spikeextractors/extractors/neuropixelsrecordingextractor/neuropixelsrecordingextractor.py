from spikeextractors import RecordingExtractor
from spikeextractors.extraction_tools import read_binary, write_to_binary_dat_format, check_get_traces_args
import shutil
import numpy as np
from pathlib import Path
import os
import xmltodict
import warnings

class NeuropixelsRecordingExtractor(RecordingExtractor):
    """
    Read raw Neurpoixels recordings
    
    This extractor is currently compatible with the 960 channel Neuropixels probes,
    where a maximum of 384 channels are recorded simulatenously. The array 
    configuration can be specified by passing the settings.xml file created by 
    OpenEphys (it can be found in the directory tree with teh recordings). If this 
    is not provided, the default configuration using 384 channels at the probe tip 
    will be used (a is warning printed).
   
    Parameters
    ----------
    filename: str
        The raw data file (usually continuous.dat)
    settings_file: None or str
        The file settings.xml generated by OpenEphys containing the array 
        configuration. If not provided the default configuration using 384 
        channels at the probe tip will be used.
    verbose: bool
        Print probe configuration
    
    """
    extractor_name = 'NeuropixelsRecordingExtractor'
    has_default_locations = False
    installed = True  # check at class level if installed or not
    is_writable = False
    mode = 'file'
    installation_mesg = ""  # error message when not installed

    def __init__(self, filename, settings_file=None, is_filtered=None, verbose=False):
        source_dir = Path(Path(__file__).parent)
        RecordingExtractor.__init__(self)
        self._datfile = Path(filename)
        self._settings_file = settings_file
        self._time_axis = 0
        self._dtype = 'int16'
        self._sampling_frequency = float(30000)
        self._offset = 0
        
        channel_locations = np.loadtxt(source_dir / 'channel_positions_neuropixels.txt')
        if self._settings_file is not None:
            with open(self._settings_file) as f:
                xmldata = f.read()
                settings = xmltodict.parse(xmldata)['SETTINGS']
            channel_info = settings['SIGNALCHAIN']['PROCESSOR'][0]['CHANNEL_INFO']
            channels = settings['SIGNALCHAIN']['PROCESSOR'][0]['CHANNEL']
            recorded_channels = []
            for c in channels:
                if c['SELECTIONSTATE']['@record'] is '1':
                    recorded_channels.append(int(c['@number']))
            used_channels = []
            used_channel_gains = []
            for c in channel_info['CHANNEL']:
                if 'AP' in c['@name'] and int(c['@number']) in recorded_channels:
                    used_channels.append(int(c['@number']))        
                    used_channel_gains.append(float(c['@gain']))
            if verbose:
                print('{} total channels found, with {} recording AP'.format(len(recorded_channels), len(used_channels)))
                print('Channels used:\n{}'.format(used_channels))
            self._numchan = len(used_channels)
            self._geom = channel_locations[:,np.array(used_channels)].T
            self._gain = used_channel_gains[0]
            self._channels = used_channels
        else:
            warnings.warn("No information about this recording available,"
                          "using a default of 384 channels at the probe tip."
                          "If the recording differs, use settings_file=settings.xml")
            self._numchan = 384
            self._geom = channel_locations[:,:384].T
            self._gain = None
            self._channels = range(384)

        self._timeseries = read_binary(self._datfile, self._numchan, self._dtype, self._time_axis, self._offset)

        # keep track of filter status when dumping
        if is_filtered is not None:
            self.is_filtered = is_filtered
        else:
            self.is_filtered = False

        assert len(self._channels) == self._timeseries.shape[0], \
           'Provided recording file does not match in size.'

        self.set_channel_locations(self._geom)
        if settings_file is not None:
            settings_file = str(Path(settings_file).absolute())
        self._kwargs = {'filename': str(Path(filename).absolute()), 'settings_file': settings_file,
                        'is_filtered': is_filtered}

    def get_channel_ids(self):
        return self._channels

    def get_num_frames(self):
        return self._timeseries.shape[1]

    def get_sampling_frequency(self):
        return self._sampling_frequency

    @check_get_traces_args
    def get_traces(self, channel_ids=None, start_frame=None, end_frame=None):
        if np.all(channel_ids == self.get_channel_ids()):
            recordings = self._timeseries[:, start_frame:end_frame]
        else:
            channel_idxs = np.array([self.get_channel_ids().index(ch) for ch in channel_ids])
            if np.all(np.diff(channel_idxs) == 1):
                recordings = self._timeseries[channel_idxs[0]:channel_idxs[0]+len(channel_idxs), start_frame:end_frame]
            else:
                # This block of the execution will return the data as an array, not a memmap
                recordings = self._timeseries[channel_idxs, start_frame:end_frame]
        if self._gain is not None:
            recordings = recordings * self._gain
        return recordings
